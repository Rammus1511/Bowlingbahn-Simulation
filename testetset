import tkinter as tk
import math
import time
import random

# ============================================
# Ultimate Bowling Simulator (Tkinter Edition)
# ============================================

WIDTH = 600
HEIGHT = 900

BALL_RADIUS = 18
PIN_W = 18
PIN_H = 40

FRICTION = 0.985
PIN_FRICTION = 0.97
FPS = 30
SPEED_FACTOR = 0.06

PIN_MASS = 0.7
BALL_MASS = 5.0


class Pin:
    def __init__(self, canvas, x, y):
        self.canvas = canvas
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.alive = True

        self.id = canvas.create_oval(
            x - PIN_W/2, y - PIN_H,
            x + PIN_W/2, y,
            fill="#ffffff",
            outline="#00ffff",
            width=2
        )

    def apply_physics(self):
        if not self.alive:
            return

        # Bewegung
        self.x += self.vx
        self.y += self.vy

        self.vx *= PIN_FRICTION
        self.vy *= PIN_FRICTION

        # Stoppen, falls fast still
        if abs(self.vx) + abs(self.vy) < 0.1:
            self.vx = self.vy = 0

        # Neu zeichnen
        self.canvas.coords(
            self.id,
            self.x - PIN_W/2, self.y - PIN_H,
            self.x + PIN_W/2, self.y
        )


class BowlingGame:
    def __init__(self, root):
        self.root = root
        root.title("ðŸŽ³ Ultimate Bowling Simulator")

        self.canvas = tk.Canvas(root, width=WIDTH, height=HEIGHT, bg="#101820")
        self.canvas.pack()

        self.frame = 1
        self.throw_in_frame = 1
        self.total_score = 0
        self.throws = []  # FÃ¼r vollstÃ¤ndiges Scoring

        self.throw_active = False
        self.aim_start = None

        self.create_lane()
        self.create_ball()
        self.create_pins()
        self.draw_ui()

        self.canvas.bind("<Button-1>", self.start_drag)
        self.canvas.bind("<ButtonRelease-1>", self.release_drag)

        self.update()

    # ----------------------------
    # UI
    # ----------------------------
    def draw_ui(self):
        self.score_text = self.canvas.create_text(
            WIDTH/2, HEIGHT - 40,
            text="Frame 1 | Wurf 1 | Score 0",
            fill="#00ffff",
            font=("Consolas", 22, "bold")
        )

    def update_ui(self):
        self.canvas.itemconfigure(
            self.score_text,
            text=f"Frame {self.frame} | Wurf {self.throw_in_frame} | Score {self.calculate_score()}"
        )

    # ----------------------------
    # Bahn & Kugel
    # ----------------------------
    def create_lane(self):
        self.canvas.create_rectangle(
            70, 50, WIDTH - 70, HEIGHT - 100,
            fill="#303030",
            outline="#00ffff",
            width=4
        )

    def create_ball(self):
        self.ball_x = WIDTH/2
        self.ball_y = HEIGHT - 150
        self.ball_vx = 0
        self.ball_vy = 0

        self.ball = self.canvas.create_oval(
            self.ball_x - BALL_RADIUS, self.ball_y - BALL_RADIUS,
            self.ball_x + BALL_RADIUS, self.ball_y + BALL_RADIUS,
            fill="#0096ff", outline="#00ffff", width=3
        )

    # ----------------------------
    # Pins setzen
    # ----------------------------
    def create_pins(self):
        self.pins = []

        base_x = WIDTH/2
        base_y = 180

        formation = [
            (0, 0),
            (-30, 50), (30, 50),
            (-60, 100), (0, 100), (60, 100),
            (-90, 150), (-30, 150), (30, 150), (90, 150)
        ]

        for dx, dy in formation:
            self.pins.append(Pin(self.canvas, base_x + dx, base_y + dy))

    # ----------------------------
    # Ziehen zum Zielen
    # ----------------------------
    def start_drag(self, e):
        if self.throw_active:
            return
        self.aim_start = (e.x, e.y)

    def release_drag(self, e):
        if not self.aim_start or self.throw_active:
            return

        dx = e.x - self.aim_start[0]
        dy = e.y - self.aim_start[1]

        # Force ist umgekehrt (ziehen nach hinten)
        self.ball_vx = -dx * SPEED_FACTOR
        self.ball_vy = -dy * SPEED_FACTOR

        self.throw_active = True

    # ----------------------------
    # Hauptsimulation
    # ----------------------------
    def update(self):
        if self.throw_active:
            self.update_ball()
            self.update_pin_collisions()

        for pin in self.pins:
            pin.apply_physics()

        self.update_ui()
        self.root.after(int(1000/FPS), self.update)

    # ----------------------------
    # Kugelphysik
    # ----------------------------
    def update_ball(self):
        self.ball_x += self.ball_vx
        self.ball_y += self.ball_vy

        self.ball_vx *= FRICTION
        self.ball_vy *= FRICTION

        # Zeichnen
        self.canvas.coords(
            self.ball,
            self.ball_x - BALL_RADIUS, self.ball_y - BALL_RADIUS,
            self.ball_x + BALL_RADIUS, self.ball_y + BALL_RADIUS
        )

        # Stoppen wenn zu langsam
        if abs(self.ball_vx) + abs(self.ball_vy) < 0.2:
            self.end_throw()

        # KollisionsrÃ¤nder
        if not (80 < self.ball_x < WIDTH - 80):
            self.ball_vx *= -1

        # Pins Ã¼berschritten â†’ fertig
        if self.ball_y < 100:
            self.end_throw()

    # ----------------------------
    # Kollision Kugel â€“ Pins
    # ----------------------------
    def update_pin_collisions(self):
        for pin in self.pins:
            if not pin.alive:
                continue

            dx = pin.x - self.ball_x
            dy = pin.y - self.ball_y
            dist = math.sqrt(dx*dx + dy*dy)

            if dist < BALL_RADIUS + PIN_W/2:
                # ImpulsÃ¼bertragung
                nx = dx / dist
                ny = dy / dist

                pin.vx += nx * 10
                pin.vy += ny * 10

                # Kugel etwas abbremsen
                self.ball_vx *= 0.7
                self.ball_vy *= 0.7

    # ----------------------------
    # Wurf beenden
    # ----------------------------
    def end_throw(self):
        self.throw_active = False

        # Getroffene Pins zÃ¤hlen
        fallen = sum(1 for p in self.pins if p.vx != 0 or p.vy != 0)

        self.record_throw(fallen)

        # Pins entfernen
        self.pins = [p for p in self.pins if p.vx == 0 and p.vy == 0]

        # Frame Logik
        if self.throw_in_frame == 1:
            if fallen == 10:
                self.next_frame()
            else:
                self.throw_in_frame = 2
        else:
            self.next_frame()

        self.reset_ball()

    def reset_ball(self):
        self.ball_x = WIDTH/2
        self.ball_y = HEIGHT - 150
        self.ball_vx = self.ball_vy = 0

        self.canvas.coords(
            self.ball,
            self.ball_x - BALL_RADIUS, self.ball_y - BALL_RADIUS,
            self.ball_x + BALL_RADIUS, self.ball_y + BALL_RADIUS
        )

    # ----------------------------
    # Scoring
    # ----------------------------
    def record_throw(self, pins):
        self.throws.append(pins)

    def calculate_score(self):
        score = 0
        index = 0
        for frame in range(10):
            if index >= len(self.throws):
                break

            # Strike
            if self.throws[index] == 10:
                score += 10 + self.get_bonus(index, 2)
                index += 1
            # Spare
            elif index + 1 < len(self.throws) and self.throws[index] + self.throws[index+1] == 10:
                score += 10 + self.get_bonus(index + 1, 1)
                index += 2
            else:
                score += self.throws[index]
                if index + 1 < len(self.throws):
                    score += self.throws[index+1]
                index += 2

        return score

    def get_bonus(self, index, count):
        return sum(self.throws[index+1:index+1+count])

    def next_frame(self):
        self.frame += 1
        self.throw_in_frame = 1
        self.canvas.delete("all")
        self.create_lane()
        self.create_pins()
        self.create_ball()
        self.draw_ui()


# ----------------------------
# Starten
# ----------------------------
root = tk.Tk()
game = BowlingGame(root)
root.mainloop()