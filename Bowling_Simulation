import tkinter as tk
import random
import math

window = tk.Tk()
window.title("Bowling Simulation")
window.geometry("960x1080+0+0")


welcomeLabel = tk.Label(window, text="Willkommen zur Bowling-Simulation der Bowling Island GmbH!", font=("Arial", 20, "bold"), fg="turquoise4", pady=20)
welcomeLabel.pack(side="top", anchor="w", pady=5)

bahnLabel = tk.Label(window, text="Welche Bahnnumer?")
bahnLabel.pack(side="top", anchor="w", pady=5)

bahnSchieberegler = tk.Scale(window, from_=1, to=12, activebackground="turquoise4", troughcolor="LightCyan3", cursor="hand2", orient=tk.HORIZONTAL)
bahnSchieberegler.pack(side="top", anchor="w", pady=5)

playerLabel = tk.Label(window, text="Wie viele COM-Spieler sollen simuliert werden?")
playerLabel.pack(side="top", anchor="w", pady=5)

playerSchieberegler = tk.Scale(window, from_=2, to=4, activebackground="turquoise4", troughcolor="LightCyan3", cursor="hand2", orient=tk.HORIZONTAL)
playerSchieberegler.pack(side="top", anchor="w", pady=5)

namenFrame = tk.Frame(window)
namenFrame.pack(side="top", anchor="w", pady=5)

playerEntries = []
playerNames = []

def update_name_fields(val):
    for widget in namenFrame.winfo_children():
        widget.destroy()
    playerEntries.clear()
    for i in range(int(val)):
        tk.Label(namenFrame, text=f"Name von Spieler {i+1}:").pack(anchor="w")
        entry = tk.Entry(namenFrame, bg="LightCyan3")
        entry.pack(anchor="w", pady=2)
        playerEntries.append(entry)

playerSchieberegler.config(command=update_name_fields)
update_name_fields(playerSchieberegler.get())

startButton = tk.Button(window, text="Simulation starten", activebackground="turquoise4", cursor="hand2")
startButton.pack(side="top", anchor="w", pady=5)

activePlayerLabel = tk.Label(window, text="Geben Sie die Spielernamen ein um fortzufahren.", font=("Arial", 15, "bold"), fg="turquoise4")
activePlayerLabel.pack(side="top", anchor="n")

canvas = tk.Canvas(window, width=600, height=600, bg="burlywood3", highlightthickness="5", highlightbackground="sienna4")
canvas.pack(pady=0)

canvas.create_rectangle(0,0,50,600, fill="tan3", outline="sienna4", width=5)
canvas.create_rectangle(559,0,609,600, fill="tan3", outline="sienna4", width=5)

# globale Strukturen
pins = []  # Liste von (pin_id, x, y, r)
ball_x, ball_y = 300, 500
ball_radius = 20
ball_dx, ball_dy = 0, 0
ball = canvas.create_oval(ball_x-ball_radius, ball_y-ball_radius, ball_x+ball_radius, ball_y+ball_radius, fill="turquoise3", outline="turquoise4", width=5)

# Spielzustand
currentPlayer = 0
currentThrow = 1
throws_done = []        # wird in start_simulation initialisiert
players_active = []     # wird in start_simulation initialisiert
total_throws_per_player = 20
pause_between_throws_ms = 800  # Pause zwischen Würfen in ms

def draw_pins():
    global pins
    # lösche alte Pins (falls noch sichtbar)
    for (pid, _, _, _) in pins:
        try:
            canvas.delete(pid)
        except Exception:
            pass
    pins.clear()

    r = 15
    x_start = 300
    y_start = 300
    positions = [
        [(x_start, y_start)],
        [(x_start-30, y_start-60), (x_start+30, y_start-60)],
        [(x_start-60, y_start-120), (x_start, y_start-120), (x_start+60, y_start-120)],
        [(x_start-90, y_start-180), (x_start-30, y_start-180), (x_start+30, y_start-180), (x_start+90, y_start-180)]
    ]
    for row in positions:
        for (x, y) in row:
            pin_id = canvas.create_oval(x-r, y-r, x+r, y+r, fill="white", outline="red", width=3)
            pins.append((pin_id, x, y, r))

draw_pins()

def update_active_player_label():
    if playerNames:
        activePlayerLabel.config(text=f"{playerNames[currentPlayer]} | {currentThrow}. Wurf | {throws_done[currentPlayer]}/{total_throws_per_player}", fg="turquoise4")
    else:
        activePlayerLabel.config(text="Noch keine Spielernamen eingegeben", fg="turquoise4")

def next_active_player_index(start_index):
    """Gibt den nächsten Index zurück, der noch aktiv ist; wenn keiner, return None."""
    n = len(playerNames)
    if n == 0:
        return None
    idx = (start_index) % n
    for _ in range(n):
        if players_active[idx]:
            return idx
        idx = (idx + 1) % n
    return None

def next_turn():
    global currentPlayer, currentThrow, ball_x, ball_y, ball_dx, ball_dy
    # Wechsel der Wurfnummer / Spieler
    if currentThrow == 1:
        currentThrow = 2
    else:
        currentThrow = 1
        # nächster aktiver Spieler
        next_idx = next_active_player_index(currentPlayer + 1)
        if next_idx is None:
            # alle fertig
            currentPlayer = 0
        else:
            currentPlayer = next_idx

    # Label aktualisieren
    update_active_player_label()

    # Kugel zurücksetzen (wird erst nach Pause bewegt)
    ball_x, ball_y = 300, 500
    canvas.coords(ball, ball_x - ball_radius, ball_y - ball_radius, ball_x + ball_radius, ball_y + ball_radius)
    # ball_dx/ball_dy werden in prepare_throw gesetzt

def check_collision():
    global pins
    if not pins:
        return
    hit_ids = []
    for (pin_id, px, py, pr) in pins:
        dx = ball_x - px
        dy = ball_y - py
        dist = math.hypot(dx, dy)
        if dist < (ball_radius + pr):
            hit_ids.append(pin_id)
    if hit_ids:
        for pid in hit_ids:
            canvas.delete(pid)
        pins = [p for p in pins if p[0] not in hit_ids]

def move_ball():
    global ball_y, ball_dy, ball_x, ball_dx
    # Wenn die Kugel gerade nicht bewegt wird, einfach weiterplanen
    if ball_dx == 0 and ball_dy == 0:
        window.after(10, move_ball)
        return

    ball_y += ball_dy
    ball_x += ball_dx
    canvas.move(ball, ball_dx, ball_dy)

    check_collision()

    # Wenn Kugel oben raus ist -> Wurf beendet
    if ball_y + ball_radius < 0:
        # Stoppe Kugel
        ball_dx, ball_dy = 0, 0
        canvas.coords(ball, 300-ball_radius, 500-ball_radius, 300+ball_radius, 500+ball_radius)

        # Wurf für aktuellen Spieler zählen
        throws_done[currentPlayer] += 1
        # Wenn Spieler seine 20 Würfe erreicht hat, markiere als fertig
        if throws_done[currentPlayer] >= total_throws_per_player:
            players_active[currentPlayer] = False

        # Kurze Pause, dann Vorbereitung für nächsten Wurf / Spieler
        window.after(pause_between_throws_ms, handle_end_of_throw)

    window.after(10, move_ball)

def handle_end_of_throw():
    # Wenn zweiter Wurf war, Pins zurücksetzen (wie vorher)
    if currentThrow == 2:
        draw_pins()

    # Prüfe ob alle Spieler fertig sind
    if not any(players_active):
        activePlayerLabel.config(text="Simulation abgeschlossen!", fg="turquoise4")
        return

    # Nächster Wurf/Spieler vorbereiten
    next_turn()
    prepare_throw()

def prepare_throw():
    global ball_dx, ball_dy, ball_x, ball_y
    # Wenn aktueller Spieler bereits fertig ist, überspringen
    if not players_active[currentPlayer]:
        # direkt zum nächsten Spieler
        next_turn()
        # falls alle fertig, handle_end_of_throw hat das bereits abgefangen
        return

    # Kugel neu positionieren
    ball_x, ball_y = 300, 500
    canvas.coords(ball, ball_x - ball_radius, ball_y - ball_radius, ball_x + ball_radius, ball_y + ball_radius)

    # Zufällige Flugrichtung / Geschwindigkeit
    ball_dx, ball_dy = random.uniform(-2.0, 2.0), -5

def start_simulation():
    global playerNames, currentPlayer, currentThrow, ball_dx, ball_dy, throws_done, players_active
    anzahl = int(playerSchieberegler.get())
    playerNames = []
    for i in range(anzahl):
        name = playerEntries[i].get().strip() if i < len(playerEntries) else ""
        playerNames.append(name if name else f"Spieler {i+1}")

    # Startwerte
    currentPlayer = 0
    currentThrow = 1
    throws_done = [0] * len(playerNames)
    players_active = [True] * len(playerNames)

    update_active_player_label()

    # Pins neu zeichnen und ersten Wurf vorbereiten
    draw_pins()
    prepare_throw()
    move_ball()

startButton.config(command=start_simulation)

window.mainloop()
