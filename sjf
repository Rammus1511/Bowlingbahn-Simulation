import tkinter as tk
import random
import math

window = tk.Tk()
window.title("Bowling Simulation")
window.geometry("1280x1080+0+0")
backgroundColor = "turquoise3"
foregroundColor = "black"
window.config(bg=backgroundColor)

welcomeLabel = tk.Label(window, text="Willkommen zur Bowling-Simulation der Bowling Island GmbH!",
                        font=("Arial", 20, "bold"),
                        fg=foregroundColor, bg=backgroundColor, pady=20)
welcomeLabel.pack(side="top", anchor="w", pady=5)

bahnLabel = tk.Label(window, text="Welche Bahnnumer?", bg=backgroundColor)
bahnLabel.pack(side="top", anchor="w", pady=5)

bahnSchieberegler = tk.Scale(window, from_=1, to=12, activebackground="turquoise4",
                             troughcolor="LightCyan3", cursor="hand2",
                             bg=backgroundColor, orient=tk.HORIZONTAL)
bahnSchieberegler.pack(side="top", anchor="w", pady=5)

playerLabel = tk.Label(window, text="Wie viele COM-Spieler sollen simuliert werden?", bg=backgroundColor)
playerLabel.pack(side="top", anchor="w", pady=5)

playerSchieberegler = tk.Scale(window, from_=2, to=4, activebackground="turquoise4",
                               troughcolor="LightCyan3", cursor="hand2",
                               bg=backgroundColor, orient=tk.HORIZONTAL)
playerSchieberegler.pack(side="top", anchor="w", pady=5)

namenFrame = tk.Frame(window)
namenFrame.pack(side="top", anchor="w", pady=5)

playerEntries = []
playerNames = []

def update_name_fields(val):
    for widget in namenFrame.winfo_children():
        widget.destroy()
    playerEntries.clear()
    for i in range(int(val)):
        tk.Label(namenFrame, text=f"Name von Spieler {i+1}:       ", bg=backgroundColor).pack(anchor="w")
        entry = tk.Entry(namenFrame, bg="LightCyan3", width=21)
        entry.pack(anchor="w", pady=2)
        playerEntries.append(entry)

playerSchieberegler.config(command=update_name_fields)
update_name_fields(playerSchieberegler.get())

startButton = tk.Button(window, text="Simulation starten", activebackground="turquoise4", cursor="hand2")
startButton.pack(side="top", anchor="w", pady=5)

activePlayerLabel = tk.Label(window, text="Geben Sie die Spielernamen ein um fortzufahren.",
                             font=("Arial", 15, "bold"),
                             fg=foregroundColor, bg=backgroundColor)
activePlayerLabel.pack(side="top", anchor="n")

# -------------------------------------------------------
# CANVAS – BOWLING BAHN
# -------------------------------------------------------
canvas = tk.Canvas(window, width=600, height=600, bg="burlywood3",
                   highlightthickness="5", highlightbackground="sienna4")
canvas.pack(side="left", padx=20)

canvas.create_rectangle(0, 0, 50, 600, fill="tan3", outline="sienna4", width=5)
canvas.create_rectangle(559, 0, 609, 600, fill="tan3", outline="sienna4", width=5)

# =======================================================
#                  K L A S S I S C H E S 
#               B O W L I N G – S C O R E B O A R D
# =======================================================
scoreboard_frame = tk.Frame(window, bg=backgroundColor)
scoreboard_frame.pack(side="right", fill="y", padx=10)

throw_labels = []          # [player][frame] → (wurf1, wurf2)
frame_score_labels = []    # [player][frame]
total_labels = []          # [player]
frame_data = []            # später gefüllt
throws_done = []           # später gefüllt

def create_scoreboard():
    tk.Label(scoreboard_frame, text="Scoreboard",
             font=("Arial", 24, "bold"), bg=backgroundColor).grid(row=0, column=0, columnspan=12, pady=10)

    tk.Label(scoreboard_frame, text="Spieler", font=("Arial", 12, "bold"),
             bg=backgroundColor).grid(row=1, column=0)

    for f in range(10):
        tk.Label(scoreboard_frame, text=f"F{f+1}", font=("Arial", 12, "bold"),
                 bg=backgroundColor).grid(row=1, column=f+1)

    tk.Label(scoreboard_frame, text="Total", font=("Arial", 12, "bold"),
             bg=backgroundColor).grid(row=1, column=11)


def init_scoreboard():
    global throw_labels, frame_score_labels, total_labels
    throw_labels = []
    frame_score_labels = []
    total_labels = []

    for p, name in enumerate(playerNames):
        row = p + 2

        tk.Label(scoreboard_frame, text=name, bg=backgroundColor,
                 font=("Arial", 15, "bold")).grid(row=row, column=0, sticky="w")

        player_throw_row = []
        player_score_row = []

        for f in range(10):
            cell = tk.Frame(scoreboard_frame, bg="white", relief="solid", bd=1)
            cell.grid(row=row, column=f+1, padx=2, pady=2)

            top = tk.Frame(cell, bg="white")
            top.pack(side="top")

            lbl1 = tk.Label(top, text="", width=2, bg="white", font=("Arial", 10))
            lbl1.pack(side="left")

            lbl2 = tk.Label(top, text="", width=2, bg="white", font=("Arial", 10))
            lbl2.pack(side="right")

            lbl_score = tk.Label(cell, text="", width=4, bg="white",
                                 font=("Arial", 10, "bold"))
            lbl_score.pack(side="bottom")

            player_throw_row.append((lbl1, lbl2))
            player_score_row.append(lbl_score)

        throw_labels.append(player_throw_row)
        frame_score_labels.append(player_score_row)

        total_lbl = tk.Label(scoreboard_frame, text="0", width=6,
                             bg="white", relief="solid", font=("Arial", 15, "bold"))
        total_lbl.grid(row=row, column=11)
        total_labels.append(total_lbl)



def symbol_for_throw(w1, w2, index, throwpos, done_w1, done_w2):
    if throwpos == 0:  # erster Wurf
        if not done_w1:
            return ""
        if w1 == 10:
            return "X"
        return "-" if w1 == 0 else str(w1)

    if throwpos == 1:  # zweiter Wurf
        if not done_w2:
            return ""

        if w1 == 10:
            return ""

        if w1 + w2 == 10:
            return "/"

        return "-" if w2 == 0 else str(w2)



def calculate_scores(throws, done):
    frame_scores = [None] * 10
    cumulative = [None] * 10

    for f in range(10):
        i1 = 2*f
        i2 = 2*f + 1

        if i1 >= done:
            break
        if i2 >= done:
            continue

        w1 = throws[i1]
        w2 = throws[i2]

        frame_score = w1 + w2

        if f == 0:
            cumulative[f] = frame_score
        else:
            prev = cumulative[f-1] or 0
            cumulative[f] = prev + frame_score

        frame_scores[f] = cumulative[f]

    total = 0
    for val in cumulative:
        if val is not None:
            total = val

    return frame_scores, total



def update_scoreboard_display():
    for p in range(len(playerNames)):
        throws = frame_data[p]
        done = throws_done[p]

        for f in range(10):
            i1 = 2*f
            i2 = 2*f + 1

            w1_done = i1 < done
            w2_done = i2 < done

            w1 = throws[i1] if w1_done else 0
            w2 = throws[i2] if w2_done else 0

            lbl1, lbl2 = throw_labels[p][f]

            lbl1.config(text=symbol_for_throw(w1, w2, f, 0, w1_done, w2_done))
            lbl2.config(text=symbol_for_throw(w1, w2, f, 1, w1_done, w2_done))

        frame_scores, total = calculate_scores(throws, done)

        for f in range(10):
            frame_score_labels[p][f].config(
                text=str(frame_scores[f]) if frame_scores[f] is not None else ""
            )

        total_labels[p].config(text=str(total))


# =======================================================
# PIN-LOGIK & SPIELSTEUERUNG (UNVERÄNDERT)
# =======================================================
pins = []
scores = []
ball_x, ball_y = 300, 500
ball_radius = 20
ball_dx, ball_dy = 0, 0
ball = canvas.create_oval(ball_x-ball_radius, ball_y-ball_radius,
                          ball_x+ball_radius, ball_y+ball_radius,
                          fill="turquoise3", outline="turquoise4", width=5)

currentPlayer = 0
currentThrow = 1
total_throws_per_player = 20
pause_between_throws_ms = 700

def draw_pins():
    global pins
    for (pid, _, _, _) in pins:
        canvas.delete(pid)
    pins.clear()

    r = 15
    x0 = 300
    y0 = 300
    rows = [
        [(x0, y0)],
        [(x0-30, y0-60), (x0+30, y0-60)],
        [(x0-60, y0-120), (x0, y0-120), (x0+60, y0-120)],
        [(x0-90, y0-180), (x0-30, y0-180), (x0+30, y0-180), (x0+90, y0-180)]
    ]
    for row in rows:
        for (x, y) in row:
            pid = canvas.create_oval(x-r, y-r, x+r, y+r,
                                     fill="white", outline="red", width=3)
            pins.append((pid, x, y, r))

draw_pins()

def update_active_player_label():
    activePlayerLabel.config(text=f"{playerNames[currentPlayer]} | Wurf {throws_done[currentPlayer]+1}/20")

def next_active_player_index(start):
    n = len(playerNames)
    for i in range(n):
        idx = (start + i) % n
        return idx
    return None

def check_collision():
    global pins
    hit = []
    for (pid, px, py, pr) in pins:
        if math.dist((ball_x, ball_y), (px, py)) < ball_radius + pr:
            hit.append(pid)

    for pid in hit:
        canvas.delete(pid)

    pins = [p for p in pins if p[0] not in hit]
    return len(hit)

def move_ball():
    global ball_x, ball_y, ball_dx, ball_dy

    if ball_dx == 0 and ball_dy == 0:
        window.after(15, move_ball)
        return

    ball_x += ball_dx
    ball_y += ball_dy
    canvas.move(ball, ball_dx, ball_dy)

    hit = check_collision()

    if ball_y < -30:
        ball_dx = ball_dy = 0
        canvas.coords(ball, 300-ball_radius, 500-ball_radius,
                      300+ball_radius, 500+ball_radius)

        frame_data[currentPlayer][throws_done[currentPlayer]] = hit
        throws_done[currentPlayer] += 1

        update_scoreboard_display()

        window.after(pause_between_throws_ms, handle_end_of_throw)
    else:
        window.after(15, move_ball)

def handle_end_of_throw():
    global currentPlayer, currentThrow

    if currentThrow == 2:
        draw_pins()

    if throws_done[currentPlayer] >= 20:
        currentPlayer = next_active_player_index(currentPlayer + 1)
    else:
        currentPlayer = next_active_player_index(currentPlayer + 1)

    currentThrow = 1 if throws_done[currentPlayer] % 2 == 0 else 2

    update_active_player_label()
    prepare_throw()

def prepare_throw():
    global ball_dx, ball_dy, ball_x, ball_y

    ball_x, ball_y = 300, 500
    canvas.coords(ball, ball_x-ball_radius, ball_y-ball_radius,
                  ball_x+ball_radius, ball_y+ball_radius)

    ball_dx = random.uniform(-2.0, 2.0)
    ball_dy = -5

def start_simulation():
    global playerNames, frame_data, throws_done

    anzahl = int(playerSchieberegler.get())
    playerNames.clear()
    for i in range(anzahl):
        name = playerEntries[i].get().strip()
        playerNames.append(name if name else f"Spieler {i+1}")

    frame_data = [[0]*20 for _ in range(anzahl)]
    throws_done = [0]*anzahl

    create_scoreboard()
    init_scoreboard()
    update_active_player_label()

    draw_pins()
    prepare_throw()
    move_ball()


startButton.config(command=start_simulation)
window.mainloop()