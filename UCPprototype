import tkinter as tk
import random
import socket
import threading
import sys

BASE_PORT = 5005  # Startport für lokale Instanzen
used_ports = set()

# ---------------- Bowling Game Klasse ----------------
class BowlingGame:
    def __init__(self):
        self.frames = []

    def roll(self, pins):
        if len(self.frames) == 0 or len(self.frames[-1]) == 2 or self.frames[-1][0] == 10:
            self.frames.append([pins])
        else:
            self.frames[-1].append(pins)

    def calculate_score_per_frame(self):
        scores = []
        total = 0
        for i in range(len(self.frames)):
            frame = self.frames[i]
            frame_score = sum(frame)
            if frame[0] == 10:
                bonus = 0
                if i + 1 < len(self.frames):
                    next_frame = self.frames[i + 1]
                    bonus = next_frame[0]
                    if len(next_frame) > 1:
                        bonus += next_frame[1]
                    elif i + 2 < len(self.frames):
                        bonus += self.frames[i + 2][0]
                frame_score += bonus
            elif sum(frame) == 10 and len(frame) == 2:
                bonus = 0
                if i + 1 < len(self.frames):
                    bonus = self.frames[i + 1][0]
                frame_score += bonus
            total += frame_score
            scores.append(total)
        return scores

    def total_score(self):
        return sum(self.calculate_score_per_frame())

# ---------------- GUI Klasse ----------------
class BowlingApp:
    def __init__(self, root, player_name, broadcast_ip="127.0.0.1"):
        self.root = root
        self.player_name = player_name
        self.game = BowlingGame()
        self.other_scores = {}
        self.broadcast_ip = broadcast_ip

        # --- Automatische Portwahl ---
        self.port = self.get_free_port()
        print(f"{self.player_name} bindet Port {self.port}")

        # --- Netzwerk Setup ---
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        try:
            self.sock.bind(("", self.port))
        except OSError as e:
            print(f"Port {self.port} kann nicht gebunden werden: {e}")
            sys.exit(1)
        threading.Thread(target=self.receive_scores, daemon=True).start()

        # --- GUI Setup ---
        self.root.title(f"Bowling - {self.player_name}")
        self.canvas = tk.Canvas(self.root, width=600, height=300, bg="lightgray")
        self.canvas.pack()

        self.round_label = tk.Label(self.root, text="Runde 1", font=("Helvetica", 16))
        self.round_label.pack(pady=10)
        self.roll_label = tk.Label(self.root, text="Würfe: 0 / 2", font=("Helvetica", 14))
        self.roll_label.pack(pady=10)

        self.roll_button = tk.Button(self.root, text="Wurf machen", font=("Helvetica", 14), command=self.roll)
        self.roll_button.pack(pady=10)

        self.score_label = tk.Label(self.root, text="Punktestand: 0", font=("Helvetica", 14))
        self.score_label.pack(pady=20)

        # Scoreboard
        self.scoreboard_frame = tk.Frame(self.root)
        self.scoreboard_frame.place(x=400, y=10)
        self.scoreboard_label = tk.Label(self.scoreboard_frame, text="Scoreboard", font=("Helvetica", 14, "bold"))
        self.scoreboard_label.pack()
        self.score_labels = {self.player_name: tk.Label(self.scoreboard_frame, text=f"{self.player_name}: 0", font=("Helvetica", 12))}
        self.score_labels[self.player_name].pack(anchor="w")

        # Pins und Ball
        self.pins = self.create_pins()
        self.ball = self.canvas.create_oval(290, 250, 310, 270, fill="red")

    def get_free_port(self):
        port = BASE_PORT
        while port in used_ports:
            port += 1
        used_ports.add(port)
        return port

    # ---------------- Pins ----------------
    def create_pins(self):
        pins = []
        x_start = 300
        y_start = 50
        spacing = 40
        rows = [1, 2, 3, 4, 5]
        for i, num_pins in enumerate(rows):
            row_pins = []
            row_x_start = x_start - (num_pins - 1) * spacing / 2
            y = y_start + (len(rows) - 1 - i) * spacing
            for j in range(num_pins):
                x = row_x_start + j * spacing
                pin = self.canvas.create_rectangle(x, y, x + 20, y + 20, fill="blue")
                row_pins.append(pin)
            pins.append(row_pins)
        return pins

    # ---------------- Wurf ----------------
    def roll(self):
        if self.game.frames and len(self.game.frames[-1]) == 1:
            remaining_pins = 10 - self.game.frames[-1][0]
        else:
            remaining_pins = 10
        pins = random.randint(0, remaining_pins)
        self.game.roll(pins)
        self.animate_ball(pins)
        self.update_ui()
        if self.is_round_over(pins):
            self.reset_pins()
        self.send_score()
        if len(self.game.frames) == 10:
            self.game_over()

    def is_round_over(self, pins):
        if self.game.frames and len(self.game.frames[-1]) == 1 and pins == 10:
            return True
        elif self.game.frames and len(self.game.frames[-1]) == 2:
            return True
        return False

    def reset_pins(self):
        for row in self.pins:
            for pin in row:
                self.canvas.itemconfig(pin, fill="blue")

    def animate_ball(self, pins):
        for i in range(250, 50, -10):
            self.canvas.coords(self.ball, 290, i, 310, i + 20)
            self.root.update()
            self.canvas.after(20)
        self.knockdown_pins(pins)
        self.canvas.coords(self.ball, 290, 250, 310, 270)

    def knockdown_pins(self, pins):
        all_pins = []
        for row in self.pins:
            all_pins.extend(row)
        if pins > len(all_pins):
            pins = len(all_pins)
        fallen_pins = random.sample(all_pins, pins)
        for pin in fallen_pins:
            self.canvas.itemconfig(pin, fill="gray")

    # ---------------- UI Update ----------------
    def update_ui(self):
        round_number = len(self.game.frames) + 1 if len(self.game.frames) < 10 else "Ende"
        self.round_label.config(text=f"Runde {round_number}")
        if self.game.frames:
            self.roll_label.config(text=f"Würfe: {len(self.game.frames[-1])} / 2")
        total_score = self.game.total_score()
        self.score_label.config(text=f"Punktestand: {total_score}")
        self.update_scoreboard()

    # ---------------- Scoreboard ----------------
    def update_scoreboard(self):
        scores = {self.player_name: self.game.total_score()}
        scores.update(self.other_scores)
        for player, score in scores.items():
            if player not in self.score_labels:
                lbl = tk.Label(self.scoreboard_frame, text=f"{player}: {score}", font=("Helvetica", 12))
                lbl.pack(anchor="w")
                self.score_labels[player] = lbl
            else:
                self.score_labels[player].config(text=f"{player}: {score}")

    # ---------------- Netzwerk ----------------
    def send_score(self):
        score = self.game.total_score()
        msg = f"{self.player_name}:{score}".encode()
        self.sock.sendto(msg, (self.broadcast_ip, self.port))

    def receive_scores(self):
        while True:
            try:
                data, addr = self.sock.recvfrom(1024)
                player, score = data.decode().split(":")
                if player != self.player_name:
                    self.other_scores[player] = int(score)
                    self.root.after(0, self.update_scoreboard)
            except:
                pass

    def game_over(self):
        final_score = self.game.total_score()
        self.show_info(f"Spiel vorbei! Dein Punktestand: {final_score}")
        self.root.quit()

    def show_info(self, message):
        info_window = tk.Toplevel(self.root)
        info_window.title("Info")
        tk.Label(info_window, text=message, font=("Helvetica", 14)).pack(pady=20)
        tk.Button(info_window, text="OK", command=info_window.destroy, font=("Helvetica", 14)).pack()

# ---------------- Main ----------------
def main():
    player_name = input("Name des Spielers: ")
    root = tk.Tk()
    app = BowlingApp(root, player_name)
    root.mainloop()

if __name__ == "__main__":
    main()
